# データ設計書

**作成日**: 2025-10-06
**対象システム**: 資料保存アプリ (Document Manager Application)

---

## 1. データ永続化方式

### 採用技術
- **SQLite 3** - プロジェクト単位の組み込みデータベース
- **Entity Framework Core 8.0** - O/Rマッパー
- **データファイル**: `workspace.db` (プロジェクトフォルダ直下に配置)

### 配置構成

```
プロジェクトフォルダ/
├── workspace.db              # メインデータベース
├── workspace.db.backup       # 自動バックアップ（保存前に作成）
├── documents/                # 資料ファイル格納先
│   ├── 設計書_rev1.pdf
│   └── 仕様書_final.docx
├── captures/                 # キャプチャ画像格納先
│   ├── 平面図_20251004.png
│   └── 断面図_20251005.png
└── exports/                  # JSONエクスポート先（オプション）
    └── backup_20251006.json
```

### SQLite採用の理由

#### メリット
1. **トランザクション保証** - ACID特性により原子性・一貫性が保証される
2. **外部キー制約** - 参照整合性を自動的に保証（孤立データの防止）
3. **高速検索** - インデックスによる効率的なクエリ実行
4. **スキーマ管理** - マイグレーション機能でバージョン管理が容易
5. **プロジェクト独立性** - フォルダ単位で完全に独立、配布・バックアップが容易
6. **実績** - デスクトップアプリケーションでの豊富な採用実績

#### 旧方式（3ファイルXML）との比較
| 項目 | 旧方式（XML） | 新方式（SQLite） |
|------|--------------|-----------------|
| ファイル数 | 3つ（DocumentMeta.xml, Status.xml, CheckPanelNode.xml） | 1つ（workspace.db） |
| 原子性 | ❌ なし（ファイル単位） | ✅ トランザクション保証 |
| 整合性 | ❌ 手動チェック必要 | ✅ 外部キー制約で自動保証 |
| GUID修復 | ❌ 必要（`RepairInvalidGuids()`） | ✅ 不要 |
| 検索性能 | ❌ 線形探索 | ✅ インデックススキャン |
| 可読性 | △ テキストだが冗長 | △ バイナリ（SQLツールで閲覧可） |
| バックアップ | △ 3ファイル同時必要 | ✅ 1ファイルコピーで完結 |

---

## 2. テーブル設計

### 2.1 ER図

```
┌─────────────────┐
│   CheckItems    │ 自己参照（階層構造）
├─────────────────┤        │
│ Id (PK)         │◄───────┘
│ Path (UNIQUE)   │   ParentId (FK)
│ Label           │
│ Status          │
│ ParentId (FK)   │
│ DisplayOrder    │
│ CreatedAt       │
│ UpdatedAt       │
└────────┬────────┘
         │ 1
         │
         │ *
┌────────▼────────────────┐
│ CheckItemDocuments      │
├─────────────────────────┤
│ Id (PK)                 │
│ CheckItemId (FK)        │───┐
│ DocumentId (FK)         │   │
│ LinkedAt                │   │
│ CaptureFile             │   │ *
│ CapturedAt              │   │
└─────────────────────────┘   │
                              │ 1
                     ┌────────▼────────┐
                     │   Documents     │
                     ├─────────────────┤
                     │ Id (PK)         │
                     │ FileName        │
                     │ RelativePath    │
                     │ FileType        │
                     │ AddedAt         │
                     └─────────────────┘
```

### 2.2 テーブル定義

#### CheckItems（チェックリスト項目）

| カラム名 | 型 | 制約 | 説明 |
|---------|-----|------|------|
| Id | INTEGER | PRIMARY KEY AUTOINCREMENT | 内部ID |
| Path | TEXT | NOT NULL, UNIQUE | 階層パス（例: "設計図面/平面図"） |
| Label | TEXT | NOT NULL | 表示名（例: "平面図"） |
| Status | TEXT | NOT NULL | 状態（Unspecified/Current/Revised/Cancelled） |
| ParentId | INTEGER | FOREIGN KEY → CheckItems(Id), NULL可 | 親項目のID（ルートはNULL） |
| DisplayOrder | INTEGER | NOT NULL | 同階層内での表示順序 |
| CreatedAt | TEXT | NOT NULL | 作成日時（ISO8601形式） |
| UpdatedAt | TEXT | NOT NULL | 更新日時（ISO8601形式） |

**インデックス**:
- `idx_checkitems_path` ON `Path`
- `idx_checkitems_parent` ON `ParentId`

**制約**:
- `Path`は一意（階層パスで識別）
- `ParentId`は自己参照外部キー（階層構造を表現）

---

#### Documents（資料）

| カラム名 | 型 | 制約 | 説明 |
|---------|-----|------|------|
| Id | INTEGER | PRIMARY KEY AUTOINCREMENT | 内部ID |
| FileName | TEXT | NOT NULL | ファイル名（例: "設計書_rev1.pdf"） |
| RelativePath | TEXT | NOT NULL, UNIQUE | 相対パス（例: "documents/設計書_rev1.pdf"） |
| FileType | TEXT | NOT NULL | ファイル種別（拡張子、例: ".pdf"） |
| AddedAt | TEXT | NOT NULL | 登録日時（ISO8601形式） |

**インデックス**:
- `idx_documents_relativepath` ON `RelativePath`
- `idx_documents_filename` ON `FileName`

**制約**:
- `RelativePath`は一意（同一ファイルの重複登録を防止）

---

#### CheckItemDocuments（チェック項目と資料の紐づけ）

| カラム名 | 型 | 制約 | 説明 |
|---------|-----|------|------|
| Id | INTEGER | PRIMARY KEY AUTOINCREMENT | 内部ID |
| CheckItemId | INTEGER | NOT NULL, FOREIGN KEY → CheckItems(Id) | チェック項目ID |
| DocumentId | INTEGER | NOT NULL, FOREIGN KEY → Documents(Id) | 資料ID |
| LinkedAt | TEXT | NOT NULL | 紐づけ日時（ISO8601形式） |
| CaptureFile | TEXT | NULL可 | キャプチャファイルパス（例: "captures/平面図_20251004.png"） |
| CapturedAt | TEXT | NULL可 | キャプチャ取得日時（ISO8601形式） |

**インデックス**:
- `idx_checkitemdocs_checkitem` ON `CheckItemId`
- `idx_checkitemdocs_document` ON `DocumentId`

**制約**:
- `CheckItemId` → `CheckItems(Id)` 外部キー（CASCADE DELETE）
- `DocumentId` → `Documents(Id)` 外部キー（CASCADE DELETE）
- 複合ユニーク制約: `(CheckItemId, DocumentId, LinkedAt)` ※履歴として同じ組み合わせを複数回紐づけ可能

**備考**:
- 1つのチェック項目に複数の資料を紐づけ可能
- 過去の紐づけも履歴として保持（削除せずに新規レコード追加）
- 最新の紐づけは`LinkedAt`の最大値で判定

---

### 2.3 （オプション）WorkHistory（作業履歴）

※ 将来拡張用。現時点では未実装。

| カラム名 | 型 | 制約 | 説明 |
|---------|-----|------|------|
| Id | INTEGER | PRIMARY KEY | 履歴ID |
| CheckItemId | INTEGER | FOREIGN KEY | チェック項目ID |
| Action | TEXT | NOT NULL | アクション（StatusChanged/DocumentLinked等） |
| OldValue | TEXT | NULL可 | 変更前の値 |
| NewValue | TEXT | NULL可 | 変更後の値 |
| Comment | TEXT | NULL可 | コメント |
| Timestamp | TEXT | NOT NULL | 実行日時 |

---

## 3. Entity Framework Core マッピング

### 3.1 エンティティクラス

#### CheckItem.cs

```csharp
public class CheckItem
{
    public int Id { get; set; }

    [Required]
    [MaxLength(500)]
    public string Path { get; set; } = "";

    [Required]
    [MaxLength(200)]
    public string Label { get; set; } = "";

    [Required]
    public ItemStatus Status { get; set; } = ItemStatus.Unspecified;

    public int? ParentId { get; set; }

    [ForeignKey(nameof(ParentId))]
    public CheckItem? Parent { get; set; }

    public List<CheckItem> Children { get; set; } = new();

    public int DisplayOrder { get; set; }

    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }

    // ナビゲーションプロパティ
    public List<CheckItemDocument> LinkedDocuments { get; set; } = new();
}
```

#### Document.cs

```csharp
public class Document
{
    public int Id { get; set; }

    [Required]
    [MaxLength(255)]
    public string FileName { get; set; } = "";

    [Required]
    [MaxLength(500)]
    public string RelativePath { get; set; } = "";

    [Required]
    [MaxLength(50)]
    public string FileType { get; set; } = "";

    public DateTime AddedAt { get; set; }

    // ナビゲーションプロパティ
    public List<CheckItemDocument> LinkedCheckItems { get; set; } = new();
}
```

#### CheckItemDocument.cs

```csharp
public class CheckItemDocument
{
    public int Id { get; set; }

    public int CheckItemId { get; set; }
    [ForeignKey(nameof(CheckItemId))]
    public CheckItem CheckItem { get; set; } = null!;

    public int DocumentId { get; set; }
    [ForeignKey(nameof(DocumentId))]
    public Document Document { get; set; } = null!;

    public DateTime LinkedAt { get; set; }

    [MaxLength(500)]
    public string? CaptureFile { get; set; }

    public DateTime? CapturedAt { get; set; }
}
```

#### ItemStatus.cs

```csharp
public enum ItemStatus
{
    Unspecified = 0,  // 未指定
    Current = 1,      // 現行
    Revised = 2,      // 改訂
    Cancelled = 3     // キャンセル
}
```

### 3.2 DbContext

```csharp
public class DocumentManagerContext : DbContext
{
    public DbSet<CheckItem> CheckItems { get; set; } = null!;
    public DbSet<Document> Documents { get; set; } = null!;
    public DbSet<CheckItemDocument> CheckItemDocuments { get; set; } = null!;

    public DocumentManagerContext(DbContextOptions<DocumentManagerContext> options)
        : base(options)
    {
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // CheckItems
        modelBuilder.Entity<CheckItem>(entity =>
        {
            entity.HasIndex(e => e.Path).IsUnique();
            entity.HasIndex(e => e.ParentId);

            entity.HasOne(e => e.Parent)
                  .WithMany(e => e.Children)
                  .HasForeignKey(e => e.ParentId)
                  .OnDelete(DeleteBehavior.Cascade);

            entity.Property(e => e.Status)
                  .HasConversion<string>();
        });

        // Documents
        modelBuilder.Entity<Document>(entity =>
        {
            entity.HasIndex(e => e.RelativePath).IsUnique();
            entity.HasIndex(e => e.FileName);
        });

        // CheckItemDocuments
        modelBuilder.Entity<CheckItemDocument>(entity =>
        {
            entity.HasIndex(e => e.CheckItemId);
            entity.HasIndex(e => e.DocumentId);

            entity.HasOne(e => e.CheckItem)
                  .WithMany(e => e.LinkedDocuments)
                  .HasForeignKey(e => e.CheckItemId)
                  .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.Document)
                  .WithMany(e => e.LinkedCheckItems)
                  .HasForeignKey(e => e.DocumentId)
                  .OnDelete(DeleteBehavior.Cascade);
        });
    }
}
```

---

## 4. データアクセスパターン

### 4.1 基本的なCRUD操作

#### チェック項目の作成

```csharp
var checkItem = new CheckItem
{
    Path = "設計図面/平面図",
    Label = "平面図",
    Status = ItemStatus.Unspecified,
    ParentId = parentItem.Id,
    DisplayOrder = 1,
    CreatedAt = DateTime.UtcNow,
    UpdatedAt = DateTime.UtcNow
};

_context.CheckItems.Add(checkItem);
await _context.SaveChangesAsync();
```

#### チェック項目と資料の紐づけ

```csharp
var link = new CheckItemDocument
{
    CheckItemId = checkItem.Id,
    DocumentId = document.Id,
    LinkedAt = DateTime.UtcNow
};

_context.CheckItemDocuments.Add(link);
await _context.SaveChangesAsync();
```

#### 階層構造の取得

```csharp
var rootItems = await _context.CheckItems
    .Where(c => c.ParentId == null)
    .Include(c => c.Children)
        .ThenInclude(c => c.Children)
    .OrderBy(c => c.DisplayOrder)
    .ToListAsync();
```

#### チェック項目に紐づく資料の取得

```csharp
var checkItemWithDocuments = await _context.CheckItems
    .Include(c => c.LinkedDocuments)
        .ThenInclude(ld => ld.Document)
    .FirstOrDefaultAsync(c => c.Path == "設計図面/平面図");

var latestDocument = checkItemWithDocuments?.LinkedDocuments
    .OrderByDescending(ld => ld.LinkedAt)
    .FirstOrDefault()?.Document;
```

### 4.2 トランザクション管理

```csharp
using var transaction = await _context.Database.BeginTransactionAsync();
try
{
    // 複数の操作を実行
    _context.CheckItems.Add(newCheckItem);
    _context.Documents.Add(newDocument);
    _context.CheckItemDocuments.Add(newLink);

    await _context.SaveChangesAsync();
    await transaction.CommitAsync();
}
catch
{
    await transaction.RollbackAsync();
    throw;
}
```

---

## 5. マイグレーション戦略

### 5.1 初期マイグレーション

```bash
# マイグレーションファイル作成
dotnet ef migrations add InitialCreate --project src/DocumentFileManager.Infrastructure

# データベース作成・更新
dotnet ef database update --project src/DocumentFileManager.Infrastructure
```

### 5.2 スキーマ変更時

```bash
# 新しいマイグレーション追加
dotnet ef migrations add AddWorkHistoryTable --project src/DocumentFileManager.Infrastructure

# 適用
dotnet ef database update --project src/DocumentFileManager.Infrastructure
```

### 5.3 バージョン管理

- マイグレーションファイルはGitで管理
- `__EFMigrationsHistory`テーブルで適用状態を追跡
- ロールバックが必要な場合は`dotnet ef database update <マイグレーション名>`

---

## 6. バックアップ・復元

### 6.1 自動バックアップ

保存処理の前に自動的にバックアップを作成：

```csharp
public async Task SaveChangesWithBackupAsync()
{
    var dbPath = _context.Database.GetDbConnection().DataSource;
    var backupPath = $"{dbPath}.backup";

    // バックアップ作成
    File.Copy(dbPath, backupPath, overwrite: true);

    try
    {
        await _context.SaveChangesAsync();
    }
    catch
    {
        // エラー時は元に戻す
        File.Copy(backupPath, dbPath, overwrite: true);
        throw;
    }
}
```

### 6.2 JSONエクスポート

```csharp
public async Task<string> ExportToJsonAsync()
{
    var export = new
    {
        ExportedAt = DateTime.UtcNow,
        CheckItems = await _context.CheckItems
            .Include(c => c.LinkedDocuments)
            .ToListAsync(),
        Documents = await _context.Documents.ToListAsync()
    };

    return JsonSerializer.Serialize(export, new JsonSerializerOptions
    {
        WriteIndented = true
    });
}
```

---

## 7. パフォーマンス考慮事項

### 7.1 インデックス戦略

- `CheckItems.Path`: 一意検索用
- `CheckItems.ParentId`: 階層取得用
- `Documents.RelativePath`: 重複チェック用
- `CheckItemDocuments.CheckItemId`: 紐づけ検索用

### 7.2 クエリ最適化

- `.AsNoTracking()`: 読み取り専用クエリで使用
- `.Include()`: N+1問題を回避
- ページング: `Skip().Take()` で大量データ対応

### 7.3 想定データ量と性能

| データ種別 | 想定件数 | 検索速度目標 |
|-----------|---------|------------|
| チェック項目 | 500件 | < 10ms |
| 資料 | 100件 | < 5ms |
| 紐づけ履歴 | 1,000件 | < 20ms |

---

## 8. 制約事項と注意点

### 8.1 同時編集

- SQLiteは**複数プロセスからの同時書き込みに制限**あり
- 要件上は単一ユーザー想定のため問題なし
- 将来的にネットワーク共有する場合は排他制御が必要

### 8.2 ファイルサイズ

- SQLiteの理論上限: 281TB
- 実用上限: 数GB程度を推奨
- 本アプリの想定: 数MB〜数十MB

### 8.3 データ移行

旧XML形式からの移行ツールが必要：
- `DocumentMeta.xml` → `Documents`テーブル
- `Status.xml` + `CheckPanelNode.xml` → `CheckItems`テーブル
- 履歴データの変換方針を別途策定

---

## 9. まとめ

### 設計のポイント

1. ✅ **単一ファイル管理** - `workspace.db`で完結
2. ✅ **階層パスで識別** - GUIDレス、人間が読める
3. ✅ **相対パスで可搬性** - プロジェクトフォルダごと移動可能
4. ✅ **トランザクション** - データ整合性を自動保証
5. ✅ **外部キー制約** - 孤立データを防止
6. ✅ **履歴管理** - CheckItemDocumentsで紐づけ履歴を保持

### 次のステップ

1. Infrastructureプロジェクト作成
2. Entity Framework Core パッケージ導入
3. エンティティクラス実装
4. DbContext実装
5. 初期マイグレーション実行
6. リポジトリパターン実装
