# 設定外部化とJSON同期の実装

**日付**: 2025-10-07
**作業者**: Claude Code

## 概要

本セッションでは、以下の2つの主要な課題を解決しました：

1. **UI設定の外部化と設定ウィンドウの実装**
   - UI設定（チェックボックス、グループボックス、レイアウト、色設定）を外部ファイル（appsettings.json）で管理
   - 設定変更用のUIウィンドウを実装し、メインウィンドウのメニューから呼び出し可能に
   - 入力値の検証機能を追加（数値範囲チェック、RGB値検証）

2. **パス設定の一元管理とJSONマスターデータ化**
   - ハードコードされたパス（ログフォルダ、DB名、checklist.jsonなど）を設定ファイルで管理
   - checklist.jsonをチェック項目のマスターデータとし、ファイル差し替えで初期定義を変更可能に
   - JSON-DB同期機能を実装し、ユーザーのチェック状態と資料紐づけを保持しながら構造を更新

---

## 実装した機能

### 1. UI設定ウィンドウ（SettingsWindow）

#### 実装内容

- **SettingsWindow.xaml**: 設定変更用のWPFウィンドウUI
  - チェックボックス設定（最小幅、フォントサイズ、マージン倍率）
  - グループボックス設定（各種最小幅、内側の間隔、枠線の太さ）
  - レイアウト設定（閾値、最大列数、列あたり幅など）
  - 色設定（大分類、中分類、小分類、デフォルトのRGB値）

- **SettingsWindow.xaml.cs**: 設定ロジックの実装
  - UISettings と PathSettings の依存性注入
  - データバインディングによる双方向同期
  - System.Text.Json による設定の永続化
  - 既存JSONセクション（Logging, PathSettings）の保持
  - 入力値の検証（ValidateSettings, ValidateRgb）

#### 技術的ポイント

```csharp
// 既存JSONを読み込み、UISettings だけを更新して他のセクションを保持
string jsonContent = File.ReadAllText(settingsPath);
using var document = JsonDocument.Parse(jsonContent);
var root = document.RootElement;

using var stream = new MemoryStream();
using (var writer = new Utf8JsonWriter(stream, new JsonWriterOptions { Indented = true }))
{
    writer.WriteStartObject();

    // Logging セクションをコピー
    if (root.TryGetProperty("Logging", out var loggingElement))
    {
        writer.WritePropertyName("Logging");
        loggingElement.WriteTo(writer);
    }

    // PathSettings セクションをコピー
    if (root.TryGetProperty("PathSettings", out var pathSettingsElement))
    {
        writer.WritePropertyName("PathSettings");
        pathSettingsElement.WriteTo(writer);
    }

    // UISettings セクションを書き込み
    writer.WritePropertyName("UISettings");
    JsonSerializer.Serialize(writer, _settings, options);

    writer.WriteEndObject();
}
```

#### 検証機能

- 数値設定の正の数チェック（MinWidth > 0、FontSize > 0など）
- 数値設定の非負数チェック（Padding >= 0、MarginDepthMultiplier >= 0など）
- RGB値の範囲チェック（0 <= R,G,B <= 255）
- エラーメッセージの日本語表示

---

### 2. パス設定の一元管理（PathSettings）

#### 実装内容

- **PathSettings.cs**: パス設定クラスの新規作成
  ```csharp
  public class PathSettings
  {
      public string LogsFolder { get; set; } = "Logs";
      public string DatabaseName { get; set; } = "workspace.db";
      public string ChecklistFile { get; set; } = "checklist.json";
      public string SettingsFile { get; set; } = "appsettings.json";
      public int ProjectRootLevelsUp { get; set; } = 5;
  }
  ```

- **appsettings.json**: PathSettingsセクションの追加
  ```json
  "PathSettings": {
    "LogsFolder": "Logs",
    "DatabaseName": "workspace.db",
    "ChecklistFile": "checklist.json",
    "SettingsFile": "appsettings.json",
    "ProjectRootLevelsUp": 5
  }
  ```

#### 変更したファイル

1. **App.xaml.cs**
   - 早期PathSettings読み込み（Serilog設定前）
   - Serilog のログフォルダパスを PathSettings.LogsFolder から取得
   - プロジェクトルート計算の動的化：
     ```csharp
     var pathSegments = Enumerable.Repeat("..", pathSettings.ProjectRootLevelsUp).ToArray();
     var projectRoot = Path.GetFullPath(Path.Combine(new[] { baseDirectory }.Concat(pathSegments).ToArray()));
     ```
   - DbContext 設定で PathSettings.DatabaseName を使用
   - DataSeeder に PathSettings.ChecklistFile を渡す

2. **DataSeeder.cs**
   - コンストラクタに `checklistFile` パラメータ追加
   - `_checklistFile` フィールドを保持し、`SyncCheckItemsAsync()` で使用

3. **SettingsWindow.xaml.cs**
   - PathSettings を注入
   - 設定ファイルパスを `_pathSettings.SettingsFile` から取得
   - 保存時に PathSettings セクションを保持

4. **MainWindow.xaml.cs**
   - SettingsWindow 生成時に PathSettings を注入

#### 技術的メリット

- **設定の一元管理**: すべてのパスが appsettings.json で管理され、コードの変更不要
- **テンプレート対応**: appsettings.json を差し替えるだけで環境に応じた設定が可能
- **保守性向上**: ハードコードされたパスがなくなり、変更箇所が明確化

---

### 3. JSON-DB同期機能（チェック項目のマスターデータ化）

#### 背景と要件

**ユーザーの要望**:
> "チェック項目はあらかじめ定義したものを使いますので、jsonファイルで保存することにしましょう。ファイルを差し替えると初期チェック項目の定義を変えられるようにしたいです"

**選択したアプローチ**:
JSON-DB同期方式（ユーザー承認済み）
- checklist.json をマスターデータとして扱う
- 起動時に毎回JSON→DB同期を実行
- ユーザーデータ（Status、資料紐づけ）は保持

#### 実装内容

**DataSeeder.cs の変更**:

1. **SeedAsync() の変更**
   ```csharp
   public async Task SeedAsync()
   {
       _logger.LogInformation("シードデータの投入を開始します");

       // チェック項目は常にJSONと同期
       await SyncCheckItemsAsync();

       // 資料とその紐づけは初回のみ投入
       if (!await _context.Documents.AnyAsync())
       {
           await SeedDocumentsAsync();
           await SeedCheckItemDocumentsAsync();
       }

       _logger.LogInformation("シードデータの投入が完了しました");
   }
   ```

2. **SyncCheckItemsAsync() の実装**
   - ChecklistLoader で JSON を読み込み
   - 統計情報をログ出力（分類数、項目数、チェック済み数）
   - `HashSet<string>` で JSON に含まれるパスを記録
   - 再帰的に階層構造を同期
   - JSON に存在しない DB 項目を削除

3. **SyncCheckItemsRecursiveAsync() の実装**
   - パス生成: `親パス/ラベル` 形式
   - 既存項目の検索: `FirstOrDefaultAsync(c => c.Path == currentPath)`
   - 既存項目の場合:
     - Label と ParentId を更新
     - **Status は維持**（ユーザーのチェック状態を保持）
   - 新規項目の場合:
     - JSON の Checked フラグに従って Status を設定
     - `ItemStatus.Current` または `ItemStatus.Unspecified`
   - 子要素を再帰的に処理

#### 同期ロジックの詳細

```csharp
private async Task SyncCheckItemsRecursiveAsync(
    List<CheckItemDefinition> definitions,
    string? parentPath,
    int? parentId,
    HashSet<string> jsonPaths)
{
    foreach (var def in definitions)
    {
        // パス生成
        var currentPath = string.IsNullOrEmpty(parentPath)
            ? def.Label
            : $"{parentPath}/{def.Label}";

        jsonPaths.Add(currentPath);

        // 既存項目を検索
        var existingItem = await _context.CheckItems
            .FirstOrDefaultAsync(c => c.Path == currentPath);

        CheckItem checkItem;

        if (existingItem != null)
        {
            // 既存項目を更新（Statusは維持）
            existingItem.Label = def.Label;
            existingItem.ParentId = parentId;
            checkItem = existingItem;

            _logger.LogDebug("チェック項目を更新: {Path} (ID={Id}, Status={Status}は維持)",
                checkItem.Path, checkItem.Id, checkItem.Status);
        }
        else
        {
            // 新規項目を追加（JSONのCheckedフラグに従う）
            checkItem = new CheckItem
            {
                Path = currentPath,
                Label = def.Label,
                Status = def.Checked ? ItemStatus.Current : ItemStatus.Unspecified,
                ParentId = parentId
            };

            await _context.CheckItems.AddAsync(checkItem);

            _logger.LogDebug("チェック項目を追加: {Path} (Status={Status})",
                checkItem.Path, checkItem.Status);
        }

        await _context.SaveChangesAsync(); // IDを取得するため即保存

        // 子要素を再帰的に処理
        if (def.Children != null && def.Children.Count > 0)
        {
            await SyncCheckItemsRecursiveAsync(def.Children, currentPath, checkItem.Id, jsonPaths);
        }
    }
}
```

#### 同期の動作

| 操作 | JSONの状態 | DBの状態 | 結果 |
|------|-----------|---------|------|
| 新規追加 | ✅ 存在 | ❌ なし | JSON の Checked フラグに従って追加 |
| 更新 | ✅ 存在 | ✅ 存在 | Label と ParentId を更新、Status は維持 |
| 削除 | ❌ なし | ✅ 存在 | DB から削除（紐づけデータも CASCADE で削除） |

#### ユーザーデータの保護

- **Status（チェック状態）**: 既存項目は維持、新規項目のみ JSON の Checked に従う
- **CheckItemDocuments（資料紐づけ）**: 外部キー制約により自動的に保持または削除
- **パスの一意性**: Path カラムをキーとして使用し、階層構造の変更に対応

---

## 変更ファイル一覧

### 新規作成
- `src/DocumentFileManager.UI/Configuration/PathSettings.cs`
- `src/DocumentFileManager.UI/SettingsWindow.xaml`
- `src/DocumentFileManager.UI/SettingsWindow.xaml.cs`
- `docs/2025-10-07_設定外部化とJSON同期の実装.md`（本ファイル）

### 変更
- `src/DocumentFileManager.UI/App.xaml.cs`
  - PathSettings の早期読み込み
  - Serilog、DbContext、DataSeeder での PathSettings 使用

- `src/DocumentFileManager.UI/MainWindow.xaml`
  - メニューバーの追加（ファイル→設定、終了）

- `src/DocumentFileManager.UI/MainWindow.xaml.cs`
  - SettingsMenuItem_Click イベントハンドラ追加

- `src/DocumentFileManager.Infrastructure/Data/DataSeeder.cs`
  - コンストラクタに checklistFile パラメータ追加
  - SeedAsync() → 常時同期に変更
  - SeedCheckItemsAsync() → SyncCheckItemsAsync() にリネーム・実装変更
  - SaveCheckItemsRecursiveAsync() → SyncCheckItemsRecursiveAsync() にリネーム・実装変更

- `appsettings.json`
  - PathSettings セクション追加

- `docs/ユースケース.md`
  - 実装状況の更新（実装済み、部分実装、未実装の正確な反映）

- `PROGRESS.md`
  - フェーズ3（UI実装）の進捗更新
  - 新規タスクの追加（UI-11, UI-12）

---

## ビルド結果

```
dotnet build --no-incremental
```

**結果**: ✅ ビルド成功
**警告**: 28個（主に AssemblyInfo.cs のフォーマット警告）
**エラー**: 0個

---

## データ統計（最新）

### checklist.json（マスターデータ）
- **分類**: 18件
- **項目**: 15件
- **チェック済み**: 8件

### workspace.db（実行時データ）
- **CheckItems テーブル**: 33レコード（JSON と同期）
- **Documents テーブル**: 3レコード（初回シード）
- **CheckItemDocuments テーブル**: 3レコード（初回シード）

---

## 技術的ハイライト

### 1. 動的パス計算
```csharp
var pathSegments = Enumerable.Repeat("..", pathSettings.ProjectRootLevelsUp).ToArray();
var projectRoot = Path.GetFullPath(Path.Combine(new[] { baseDirectory }.Concat(pathSegments).ToArray()));
```

**利点**: ProjectRootLevelsUp の設定値を変更するだけで、プロジェクトルートの場所を調整可能

### 2. JSONセクション保持
```csharp
// 既存のJSONを読み込み、必要なセクションのみ更新
using var document = JsonDocument.Parse(jsonContent);
var root = document.RootElement;

// Logging, PathSettings セクションをコピー
// UISettings セクションのみ書き換え
```

**利点**: 設定ファイルの一部だけを更新でき、他の設定を破壊しない

### 3. パスベース同期
```csharp
var existingItem = await _context.CheckItems
    .FirstOrDefaultAsync(c => c.Path == currentPath);
```

**利点**: 階層構造の変更（親の変更など）に柔軟に対応できる

### 4. HashSet による削除検出
```csharp
var jsonPaths = new HashSet<string>();
// ... 同期処理でパスを追加 ...
var itemsToDelete = allDbItems.Where(item => !jsonPaths.Contains(item.Path)).ToList();
```

**利点**: O(1) の高速検索で、JSON に存在しない項目を効率的に検出

---

## 次のステップ

### 完了したタスク
- ✅ UI設定の外部化
- ✅ 設定ウィンドウの実装
- ✅ パス設定の一元管理
- ✅ JSON-DB同期機能
- ✅ 入力値検証機能
- ✅ ユースケース.md の更新

### 今後の作業候補
1. **UI実装の継続**
   - 資料登録UI（ファイル選択ダイアログ、ドラッグ&ドロップ）
   - 資料とチェック項目の紐づけUI
   - 画面キャプチャ機能

2. **機能強化**
   - ファイル存在検証
   - データバックアップ機能
   - 検索・フィルタ機能

3. **テスト**
   - ユニットテスト（ドメイン層、リポジトリ層）
   - 統合テスト（主要ユースケース）

---

## まとめ

本セッションでは、設定管理の改善とデータ同期機能の実装により、以下の目標を達成しました：

1. **保守性の向上**: ハードコードされたパスを排除し、設定ファイルで一元管理
2. **ユーザビリティの向上**: UI設定をGUIで変更可能に
3. **柔軟性の向上**: checklist.json をマスターデータ化し、テンプレートの差し替えに対応
4. **データ整合性**: ユーザーのチェック状態を保持しながらJSON定義を更新

これにより、アプリケーションの設定管理が大幅に改善され、運用面での柔軟性が向上しました。
