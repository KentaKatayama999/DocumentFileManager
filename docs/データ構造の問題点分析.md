# データ構造の問題点分析

**作成日**: 2025-10-06

---

## 1. 現状のデータ構造

### 1.1 ファイル構成
```
データファイル/
├── DocumentMeta.xml          # 資料メタデータ
├── Status.xml                # チェック項目の状態
└── CheckPanelNode.xml        # チェックリスト構造定義
```

### 1.2 データモデル関連図
```
┌───────────────────┐
│ CheckPanelNode    │  ← ツリー構造定義（静的）
│ (構造定義)        │
├───────────────────┤
│ Label             │
│ Guid (葉のみ)     │
│ Children[]        │
└─────────┬─────────┘
          │ Guidで対応
          ↓
┌───────────────────┐
│ ItemState         │  ← チェック項目の状態（動的）
│ (状態管理)        │
├───────────────────┤
│ Guid              │
│ Label             │
│ Status            │──┐
│ DocumentGuid      │  │ Guidで参照
│ CaptureFile       │  │
│ CapturedAt        │  │
│ PastDatas[]       │  │ 履歴配列
└───────────────────┘  │
                       ↓
          ┌────────────────────┐
          │ DocumentMeta       │  ← 資料メタデータ
          │ (ファイル情報)     │
          ├────────────────────┤
          │ Guid               │
          │ FileName           │
          │ FullPath           │
          └────────────────────┘
```

---

## 2. 問題点

### 2.1 【問題1】複数ファイルによる分散管理

**現状**:
- 3つの独立したXMLファイルで管理
- 各ファイルは独自のタイミングで読み書き

**問題点**:
1. **保存の原子性がない**
   - 3ファイルのうち1つだけ保存失敗すると不整合状態になる
   - トランザクション管理が困難

2. **読み込み順序依存**
   ```csharp
   // UC-021より
   1. CheckPanelNode.xml を読み込み
   2. Status.xml を読み込み
   3. DocumentMeta.xml を読み込み
   4. GUID修復処理を実行  ← この処理が必要になる理由が分散管理
   ```

3. **バックアップの複雑さ**
   - 3ファイル全てを同時にバックアップする必要
   - 部分的なバックアップでは復元できない

**影響**:
- データ破損リスク増加
- 復元処理の複雑化
- テスト・デバッグの困難さ

---

### 2.2 【問題2】GUID参照による間接的な紐づけ

**現状**:
```
PanelNode.Guid (葉ノード)
    → ItemState.Guid (状態)
        → ItemState.DocumentGuid
            → DocumentMeta.Guid (資料)
```

**問題点**:
1. **参照整合性チェックが必要**
   ```csharp
   // UC-022の検証処理より
   foreach (var itemState in ItemStateCollection) {
       if (itemState.DocumentGuid.HasValue) {
           var doc = DocumentMetaCollection.FirstOrDefault(
               d => d.Guid == itemState.DocumentGuid
           );
           if (doc == null || !File.Exists(doc.FullPath)) {
               // クリーンアップ処理
           }
       }
   }
   ```

2. **GUID修復処理の必要性**
   - `RepairInvalidGuids()` という処理が必要になっている
   - なぜ無効なGUIDが発生するのか？
   - 根本原因が不明

3. **デバッグの困難さ**
   - GUIDは人間が読めない
   - ログを見ても何の資料/項目か分からない
   ```
   警告: 資料が見つかりません - Guid: abc-123-456-...
   # どの資料？何のチェック項目？
   ```

**影響**:
- 保守性の低下
- 整合性維持コストの増加
- トラブルシューティングの困難

---

### 2.3 【問題3】PanelNodeとItemStateの二重管理

**現状**:
- `CheckPanelNode.xml`: チェックリストの**構造**（ツリー）
- `Status.xml`: チェック項目の**状態**（フラットなコレクション）

**問題点**:
1. **同じ情報の重複**
   - `PanelNode.Label` と `ItemState.Label` が重複
   - `PanelNode.Guid` と `ItemState.Guid` が重複（葉ノードのみ）

2. **同期の複雑さ**
   ```
   ケース1: ユーザーがチェック項目を追加（UC-014）
   → PanelNode に新ノード追加
   → ItemState を新規生成
   → 両方を保存

   ケース2: チェック項目を削除したら？
   → どちらを削除？両方？
   → 状態だけ残す？履歴として？
   ```

3. **構造変更時のマイグレーション**
   - PanelNode構造を変更すると、ItemStateも再生成が必要
   - 既存の状態データをどう引き継ぐ？

**影響**:
- データ不整合リスク
- 実装の複雑化
- 運用負荷の増加

---

### 2.4 【問題4】PastDatasによる履歴管理の曖昧さ

**現状**:
```csharp
ItemState {
    DocumentGuid: "current-doc-guid",
    CaptureFile: "current.png",
    CapturedAt: DateTime,
    PastDatas: [
        { DocumentGuid: "old-1", CaptureFile: "old1.png", ... },
        { DocumentGuid: "old-2", CaptureFile: "old2.png", ... }
    ]
}
```

**問題点**:
1. **履歴の用途が不明確**
   - 何のための履歴？
   - どう活用される？
   - 表示するUI機能はある？

2. **履歴の保持期間・上限が未定義**
   - 無限に増え続ける？
   - メモリ圧迫の可能性

3. **履歴とバックアップの混同**
   - `.backup` ファイルとPastDatasの役割分担は？
   - どちらで復元すべき？

**影響**:
- データ肥大化
- 仕様の曖昧さ
- パフォーマンス低下の可能性

---

### 2.5 【問題5】ファイルパスのハードコーディングリスク

**現状**:
```csharp
DocumentMeta {
    Guid: "abc-123",
    FileName: "設計書.pdf",
    FullPath: "C:\Documents\設計書.pdf"  ← 絶対パス
}

ItemState {
    CaptureFile: "C:\Captures\xyz_20251004.png"  ← 絶対パス
}
```

**問題点**:
1. **ポータビリティがない**
   - 別PCにデータを移行できない
   - ネットワークパスは環境依存

2. **ファイル移動に弱い**
   - ファイルを移動すると参照が切れる
   - UC-022の検証でクリーンアップされてしまう

3. **相対パス管理の欠如**
   - プロジェクトフォルダ基準の相対パスにできない

**影響**:
- データの可搬性ゼロ
- ファイル整理時の事故
- チーム共有の困難

---

### 2.6 【問題6】XMLフォーマットの制約

**現状**:
- すべてXMLで保存（UTF-8）
- 手動編集は困難

**問題点**:
1. **可読性が低い**
   ```xml
   <ItemState>
       <Guid>xyz-789-abc-def-...</Guid>
       <Label>平面図</Label>
       <Status>Current</Status>
       <DocumentGuid>abc-123-...</DocumentGuid>
   </ItemState>
   ```
   - GUIDだらけで人間には読めない

2. **バージョニングが困難**
   - スキーマ変更時の互換性維持が大変
   - マイグレーションツールが必要

3. **マージ不可**
   - Git等でのマージができない
   - チーム開発に不向き

**影響**:
- 手動メンテナンスの困難
- バージョンアップの困難
- チーム開発の障壁

---

## 3. 問題の根本原因

### 3.1 設計思想の不一致

**想定される背景**:
- `PanelNode`: 静的な「マスタデータ」として設計
- `ItemState`: 動的な「トランザクションデータ」として設計
- `DocumentMeta`: 「リソース管理」として設計

**問題**:
この3つを**独立したエンティティ**として扱った結果：
- 関連をGUIDで表現せざるを得ない
- 整合性維持が開発者の責任になる
- 複雑な検証・修復ロジックが必要

### 3.2 正規化しすぎた設計

**データベース的な正規化**:
```
DocumentMeta (資料テーブル)
ItemState    (状態テーブル)
PanelNode    (定義テーブル)
```

**問題**:
- RDBMSではないのにRDBMS的設計
- 外部キー制約がない
- トランザクション管理がない
- JOIN処理を手動実装

---

## 4. 改善の方向性（提案）

### 4.1 案1: 単一ファイル統合 + 階層構造

```json
{
  "checkList": {
    "root": {
      "label": "ルート",
      "children": [
        {
          "label": "設計図面",
          "children": [
            {
              "label": "平面図",
              "status": "Current",
              "document": {
                "fileName": "設計書.pdf",
                "relativePath": "docs/設計書.pdf"
              },
              "capture": {
                "fileName": "平面図.png",
                "capturedAt": "2025-10-04T10:30:00"
              }
            }
          ]
        }
      ]
    }
  },
  "documents": [
    { "fileName": "設計書.pdf", "relativePath": "docs/設計書.pdf" }
  ]
}
```

**メリット**:
- 原子性のある保存
- 構造と状態の一体化
- 相対パスで可搬性向上
- 人間が読める

### 4.2 案2: イベントソーシング

**現状の問題**:
- 「現在の状態」だけを保存
- 履歴が曖昧（PastDatas）

**改善案**:
```json
{
  "events": [
    { "type": "CheckItemCreated", "itemId": "平面図", "timestamp": "..." },
    { "type": "DocumentLinked", "itemId": "平面図", "docPath": "...", "timestamp": "..." },
    { "type": "StatusChanged", "itemId": "平面図", "status": "Current", "timestamp": "..." }
  ]
}
```

現在の状態はイベントから再生成。

### 4.3 案3: SQLite導入

**メリット**:
- トランザクション保証
- 外部キー制約
- SQLで柔軟なクエリ
- マイグレーション機能（Entity Framework等）

**デメリット**:
- 依存ライブラリ増加
- テキストエディタで見られない

---

## 5. まとめ

### 主要な問題点
1. ✗ 3ファイル分散管理による不整合リスク
2. ✗ GUID参照の複雑さと保守性の低下
3. ✗ PanelNodeとItemStateの二重管理
4. ✗ 履歴管理の曖昧さ
5. ✗ 絶対パスによるポータビリティ欠如
6. ✗ XMLの可読性・保守性の低さ

### 推奨アクション
- [x] データモデルの再設計を検討
- [x] 単一ファイル化 or DB化の選択 → **SQLite採用決定**
- [x] 相対パス管理の導入
- [x] 履歴管理の要件明確化

---

## 6. 採用決定: SQLite（案3）

**決定日**: 2025-10-06

### 採用理由

以下の要件検討の結果、**SQLiteをプロジェクト単位で配置する構成**を採用しました。

#### 1. データ整合性の確保
現行方式（3ファイルXML）では以下の問題がありました：
- ファイル単位の保存で原子性がない（一部だけ保存失敗すると不整合）
- 手動での参照整合性チェックが必要（`RepairInvalidGuids()`等）
- GUID参照の孤立データが発生するリスク

**SQLiteの採用により**:
- ✅ トランザクション（ACID特性）で原子性を保証
- ✅ 外部キー制約で参照整合性を自動保証
- ✅ GUID修復処理が不要

#### 2. プロジェクト単位の独立性
配置方式: `プロジェクトフォルダ/workspace.db`

**メリット**:
- プロジェクト間のデータ汚染を完全に防げる
- フォルダごとコピーで配布・アーカイブが容易
- スキーマ変更をプロジェクト単位で段階適用できる
- 大規模な集中DBを管理する必要がない

**実務的な評価**:
> プロジェクト単位でworkspace.dbのようなSQLiteを配置する構成は実務的にもよく採用されており、
> 現在のユースケース（単体PCまたは限定的な共有）なら問題ありません。
> プロジェクトの複製やバックアップもフォルダごとコピーで済むため、
> 既存の運用（プロジェクトフォルダを配布・保管する）に素直に乗ります。

#### 3. パフォーマンスと拡張性
- インデックスによる高速検索（要件「100件で1秒以内」を十分クリア）
- SQLクエリで複雑なフィルタ・集計が容易
- Entity Framework Coreでマイグレーション管理が標準化

#### 4. バックアップと運用性
- 1ファイル（workspace.db）のコピーで完全バックアップ
- 保存前に`.backup`を自動作成（障害時の復旧容易）
- ZIPアーカイブやGit LFSでのバージョン管理も可能

### 注意事項と対策

#### 同時編集の制限
SQLiteは複数プロセスからの同時書き込みに制限があります。

**現時点の対応**:
- 要件上は単一ユーザー想定のため問題なし
- アプリケーション起動時に排他ロック取得で二重起動を防止

**将来の拡張時**:
- ネットワーク共有フォルダでの同時編集が必要になった場合:
  1. ファイルロック機構の導入
  2. 楽観的同時実行制御（タイムスタンプベース）
  3. 中央DBへの移行検討（PostgreSQL等）

#### データ移行
旧XML形式（DocumentMeta.xml, Status.xml, CheckPanelNode.xml）からの移行:
- 移行ツールを別途作成（マイグレーションスクリプト）
- 段階的な移行プロセスを策定
- 移行後の検証手順を整備

### 技術スタック

| 項目 | 技術 | バージョン |
|------|------|----------|
| データベース | SQLite | 3.x |
| O/Rマッパー | Entity Framework Core | 8.0 |
| パッケージ | Microsoft.EntityFrameworkCore.Sqlite | 8.0.0 |
| パッケージ | Microsoft.EntityFrameworkCore.Design | 8.0.0 |

### データ構造の変更点

| 旧方式 | 新方式 |
|--------|--------|
| 3ファイル（XML） | 1ファイル（SQLite） |
| GUID参照 | 階層パス + 内部ID |
| PanelNode + ItemState 二重管理 | CheckItemに統合 |
| 絶対パス | 相対パス |
| 手動整合性チェック | 外部キー制約で自動保証 |

詳細は[データ設計書.md](./データ設計書.md)を参照してください。

---

**次のステップ**:
1. [データ設計書](./データ設計書.md)に基づいた実装
2. Infrastructureプロジェクトの作成
3. Entity Framework Coreの設定
4. 初期マイグレーションの実行
